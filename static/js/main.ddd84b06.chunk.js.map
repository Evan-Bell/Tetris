{"version":3,"sources":["reportWebVitals.js","BoardDisplay.js","Controls.js","App.js","game.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","__webpack_require__","e","then","bind","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","StylizedBoardDisplay","props","game_board","inputboard","width","inputwidth","height","inputheight","rows_ind","row","push","cols_ind","col","c","react_default","a","createElement","className","map","id","board","ControlsDisplay","score","level","hold","next","highscore","highlevel","droptime","gameBoard","Board","_this","this","Object","classCallCheck","pivot","pieces","coor","hold_swapped","interval","setInterval","piece_fall","create_board","temp","next_piece_grab","mutate","specific_piece","length","sort","Math","random","piece_num","pop","piece","2","3","4","5","6","7","8","g","update_ghost","ms","Promise","resolve","setTimeout","update_coor","flag","i","solidify_piece","over_stack_check","typ","counter","xPivot","yPivot","new_coor","slice","_this$shift_coor","shift_coor","new_coor_down","new_piv_down","_this$shift_coor2","new_coor_up","new_piv_up","_this$shift_coor3","new_coor_left","new_piv_left","_this$shift_coor4","new_coor_right","new_piv_right","coor_is_valid","Coordinates","piv","ver","hor","shifted_coor","coors","shift_piece","_this2","check","score_increase","clearInterval","diff","gen_piece","next_piece","line_cleared_check","ghost_dist","rows_clear","row_cleared","j","cleared_lines_len","max","apply","each","level_score","reset_all","pow","floor","sqrt","time_drop_calc","lines_cleared","increment","level_update","_this3","App","possibleConstructorReturn","getPrototypeOf","call","handleKeyPress","event","key","console","log","state","timerID","update_board","setState","move_left","move_right","move_drop","rotate_piece","move_hold_swap","stop_drop","start_drop","hard_drop","concat","type","onKeyDown","handleInput","onChange","min","value","React","Component","ReactDOM","render","App_App","document","getElementById"],"mappings":"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","file":"static/js/main.ddd84b06.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\n\n\nexport default function StylizedBoardDisplay(props) {\n\n    var game_board = props.inputboard;\n    var width = props.inputwidth;\n    var height = props.inputheight;\n    \n    //DISPLAYS THE BOARD IN A WAY THAT I CAN VISUALLY CONFIRM CHANGES\n    let rows_ind = [];\n    for (let row = 0; row < height; row++) {\n      rows_ind.push(row);\n    }\n\n    let cols_ind = [];\n    for (let col = 0; col < width+2; col++) {\n      cols_ind.push(col);\n    }\n\n\n    let c = 'c'; //USED TO MAKE ID FOR EACH CELL 'C' FOLLOWED BY NUMBER\n    let r = 'r';\n    return (\n        <div className=\"TetrisBoard\">\n            <tr className='TetrisRow'> \n            {cols_ind.map((col) => <td className='TetrisCell' id={c+'Border'}></td> )} \n            </tr>\n        \n            {rows_ind.map((row) => (\n                <tr className='TetrisRow' id={r+row}> \n                    <td className='TetrisCell' id={c+'Border'}></td>\n                    {game_board.board[row].map((col) => <td className='TetrisCell' id={c+col}></td> )} \n                    <td className='TetrisCell' id={c+'Border'}></td>\n                </tr>\n            ))}\n\n            <tr className='TetrisRow'> \n            {cols_ind.map((col) => <td className='TetrisCell' id={c+'Border'}></td> )} \n            </tr>\n        </div>\n    );\n}","import React from 'react';\n\nexport default function ControlsDisplay(props) {\n    var game_board = props.inputboard\n    return (\n        <div className=\"TetrisControls\">\n            <div className='score-display'>Score: {game_board.score}</div>\n            <div className='level-display'>Level: {game_board.level}</div>\n            <div className='hold-display'>Hold: {game_board.hold}</div>\n            <div className='next-display'>Next: {game_board.next}</div>\n            <div className='highscore-display'>Highscore: {game_board.highscore}</div>\n            <div className='highlevel-display'>Highlevel: {game_board.highlevel}</div>\n            <div className='droptime'>droptime: {game_board.droptime}</div>\n        </div>\n    );\n}\n\n","import React from 'react'\nimport StylizedBoardDisplay from \"./BoardDisplay\"\nimport ControlsDisplay from './Controls';\nimport Board from \"./game\"\n\n\n\nconst width = 10;\nconst height = 24; //playable height is 20\n\n\nvar gameBoard = new Board(width, height);\n  \n //ADD TIME DROPS AND TIME DELAY\n //IMPROVE THE CSS/REACT/JS ASPECT OF SHOWING SO IT IS LESS LAGGY AND LOOKS BETTER\n // MAKE IT SO THE KEYPRESS IS APPLIED WHENEVER SOMEONE IS IN THE TETRIS WINDOW / MOUSE PRESSED IT\n //LEARN CSS FOR GOD SAKE\n\n\n export default class App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            game_board: gameBoard,\n            score: {},\n            level:{},\n            hold: {},\n            next:{},\n            highscore:{},\n            highlevel: {},\n            droptime: {},\n            interval: {}\n        };\n    }\n\n    componentDidMount() {\n        this.timerID = setInterval(\n          () => this.update_board(),\n          100\n        );\n      }\n    \n    componentWillUnmount() {\n        clearInterval(this.timerID);\n    }\n    \n    update_board() {\n        this.setState({\n            game_board: gameBoard\n        });\n    }\n\n    handleKeyPress = (event) => {\n        if(event.key === 'Enter'){\n          console.log('enter press here! ')\n        }\n    }\n\n    handleInput(event){ //MAKE THIS AUTOCLICK INSTEAD OF HAVING TO GO INTO TEXT BOX\n        switch(event.key) {\n            case 'ArrowLeft': \n                gameBoard.move_left();\n              break;\n            case 'ArrowRight': \n                gameBoard.move_right();\n                break;\n            case 'ArrowDown': \n                gameBoard.move_drop();\n                break;\n            case 'ArrowUp': \n                gameBoard.rotate_piece();\n                break;\n            case 'h':\n                gameBoard.move_hold_swap();\n                break;\n            case '-':\n                gameBoard.stop_drop();\n                break;\n            case '=':\n                gameBoard.start_drop();\n                break;\n            case ' ':\n                gameBoard.hard_drop();\n                break;\n        }\n    }\n    \n    \n    render() {\n        return (\n            <div className=\"TetrisGame\">\n                <h2>{`Interval: ${this.interval}`}</h2>\n                <input type='text' onKeyDown={this.handleInput} onChange={e => this.update_board()}/>\n                <input type=\"range\" min=\"1\" value={this.interval} max=\"100\" onChange={e => this.update_board()}/>\n                <ControlsDisplay inputboard={this.state.game_board}/>\n                <StylizedBoardDisplay inputboard={this.state.game_board} inputheight={height} inputwidth={width}/>\n            </div>\n        );\n     }\n}","/*\nRULES FOR TETRIS\n\nSIZE OF BOARD = 10 WIDE, 20 TALL (24 TALL, BUT TOP 4 ARE NOT IN PLAY)\nTYPES OF PIECES = { ALL ARE SIZE 4 SQUARES :\n  T, \n  SQUARE, \n  LEFT L,\n  RIGHT L,\n  LEFT Z,\n  RIGHT Z,\n  STRAIGHT\n}\n\nACTIONS AVAIBLE = {\n  MOVE LEFT,\n  MOVE RIGHT, \n  DOWN,\n  ROTATE,\n  MOVE TO HOLD\n}\n\n\n\"NEXT\" contains 3 pieces to come next, not including one in play\n\"HOLD\" contains 1 piece which swaps with the piece in play\n\n\nSCORING = { BASED ON LEVEL (N) MULTIPLIED BY  NUMBER OF LINES CLEARED AT ONCE\n  ONE LINE = 40(N+1)\n  TWO LINES = 100(N+1)\n  THREE LINES 300(N+1)\n  FOUR LINES 1200(N+1)\n}\n*/\nexport default class Board {\n  //USED TO INITIALIZE THE BOARD\n\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.board = [];\n    this.score = 0;\n    this.level = 0;\n    this.pivot = [];\n    this.pieces = [2,3,4,5,6,7,8] //tracks for tetris \"random generator\"\n    this.coor = [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ];\n    this.hold = 0;\n    this.hold_swapped = false\n    this.next = [0, 0, 0]; //stores next three not including one in play\n    this.highlevel = 0;\n    this.highscore = 0;\n    this.droptime = 900;\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n    this.create_board();\n  }\n\n  create_board() {\n    //CREATES BLANK 2D ARRAY OF GIVEN SIZE (HEIGHT AND WIDTH)\n    let temp = [];\n    for (let row = 0; row < this.height; row++) {\n      temp[row] = [];\n      for (let col = 0; col < this.width; col++) {\n        temp[row][col] = 0; //0;\n      }\n    }\n    this.board = temp;\n    this.next_piece_grab();\n\n    return this.board;\n  }\n\n  /*\n  TYPES OF PIECES AND CODE VALUES ASSIGNED TO THEM = {\n    EMPTY = 0\n    GHOST/VISUALIZED = 1\n    T = 2\n    SQUARE = 3\n    STRAIGHT LINE = 4\n    NORMAL L = 5\n    BACKWARDS L = 6\n    LEFT Z = 7\n    RIGHT Z = 8\n    (ALL ABOVE ARE FOR PEICE THAT ARE PLACED)\n    (FOR PIECES THAT ARE NOT PLACES, THE CODE WILL BE NEGATIVE THE NUMBER, SO UNPLACED T IS -1)\n  }\n  */\n\n\n\n  gen_piece(mutate, specific_piece) {\n    //GENERATES A NEW PIECE\n    const piece_codes = {\n      //EACH PIECE HAS A NUMBER AS A KEY (COLOR AND PEICE INDETIFIER) AND A SET OF 4 COORDINATEES, AND A PIVOT POINT\n      2: [\n        [0, 0],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], // RELATIVE PIVOT POINT\n      ],\n      3: [\n        [0, 0],\n        [0, 1],\n        [1, 0],\n        [1, 1],\n        [0.5, 0.5], //RELATIVE PIVOT POINT\n      ],\n      4: [\n        [0, -1],\n        [0, 0],\n        [0, 1],\n        [0, 2],\n        [0.5, 0.5], //RELATIVE PIVOT POINT\n      ],\n      5: [\n        [0, 1],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      6: [\n        [0, -1],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      7: [\n        [0, -1],\n        [0, 0],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      8: [\n        [1, -1],\n        [0, 0],\n        [1, 0],\n        [0, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n    };  \n\n    if(this.pieces.length === 0){ //MAKES IT SO THAT EACH PIECE GETS GIVEN EVENLY\n      this.pieces = [2,3,4,5,6,7,8];\n    }\n    this.pieces = this.pieces.sort(() => {\n      return Math.random() - 0.5;\n    })\n    let piece_num = this.pieces.pop(this.pieces.length-1); //GETS LAST INT FROM RANDOM SORT LIST\n    if (specific_piece > 1) {\n      piece_num = 1 * specific_piece;\n    }\n    if (mutate) {\n      let piece = piece_codes[piece_num];\n      for (let g = 0; g < 4; g++) { //SHIFTS THE PIECE OVER TO CENTER OF BOARD INSTEAD OF DEAD TOP\n        this.board[piece[g][0] + 1][piece[g][1] + 4] = -piece_num;\n      }\n\n      this.pivot = piece[4];\n      this.pivot[0] += 1;\n      this.pivot[1] += 4; //MOVE THE PIVOT ACCORDINGLY WITH THE PIECE SHIFT ABOVE\n      this.update_ghost();\n    }\n    return piece_num;\n  }\n\n  sleep(ms) {//USED FOR FALLING TIMEOUT\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  piece_fall() {\n    //DROPS PIECE DOWN ONE\n    let coor = this.update_coor(); //grabs Coordinates\n    let flag = true;\n    for (let i = 0; i < 4; i++) {\n      let row = coor[i][0];\n      let col = coor[i][1];\n      if (row === this.height - 1 || this.board[row + 1][col] > 1) {\n        flag = false;\n      }\n    }\n    if (flag !== true) {\n      this.solidify_piece();\n      this.over_stack_check();\n    } else {\n      //REMOVES THE SPOT AT EACH OF COORDINATES AND ADDS ONE BELOW EACH COORDINATE\n\n      let typ = this.board[coor[0][0]][coor[0][1]];\n      for (let i = 0; i < 4; i++) {\n        this.board[coor[i][0]][coor[i][1]] = 0;\n      }\n      for (let i = 0; i < 4; i++) {\n        this.board[coor[i][0] + 1][coor[i][1]] = typ;\n      }\n      this.pivot[0] += 1;\n    }\n    return flag;\n  }\n\n  update_coor() {\n    let temp = [[], [], [], []];\n    let counter = 0;\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] < 0) {\n          this.coor[counter][0] = row;\n          this.coor[counter][1] = col;\n          temp[counter][0] = row;\n          temp[counter][1] = col;\n          counter++;\n        }\n      }\n    }\n    return temp;\n  }\n\n  rotate_piece() {\n    //ROTATES THE PIECE CLOCKWISE\n    // Rules for rotation taken from here https://gamedev.stackexchange.com/questions/17974/how-to-rotate-blocks-in-tetris\n\n    let coor = this.update_coor(); //grabs Coordinates\n\n    //COVERT EACH POINT RELATIVE TO PIVOT then rotates and stores in new_coor\n    let xPivot = this.pivot[0];\n    let yPivot = this.pivot[1];\n    let new_coor = coor.slice(); //copies but without same memory pointer\n    for (let g = 0; g < 4; g++) {\n      let temp = [0, 0];\n      temp[0] = xPivot + (coor[g][1] - yPivot);\n      temp[1] = yPivot + -(coor[g][0] - xPivot);\n      new_coor[g] = temp;\n    }\n\n    let typ = this.board[coor[0][0]][coor[0][1]]; //Stores value to use for replacing same piece\n    //REMOVES THE OLD COOR (NEW COOR IS STILL STORED, SO IT IS OK)\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] = 0;\n    }\n\n    //GENERATES COORDINATES AND PIV SHIFTED IN EVERY DIR\n    let {new_coor_down, new_piv_down} = this.shift_coor(new_coor, this.pivot, 1, 0);\n    let {new_coor_up, new_piv_up}= this.shift_coor(new_coor, this.pivot, -1, 0);\n    let {new_coor_left, new_piv_left} = this.shift_coor(new_coor, this.pivot, 0, -1);\n    let {new_coor_right, new_piv_right} = this.shift_coor(new_coor, this.pivot, 0, 1);\n\n    //CHECKS THAT NEW POSSIBLE COOR ARE VALID\n    if (this.coor_is_valid(new_coor)) {\n      let throw_away;\n    } else if (this.coor_is_valid(new_coor_down)) {\n      new_coor = new_coor_down;\n      this.pivot = new_piv_down;\n    } else if (this.coor_is_valid(new_coor_left)) {\n      new_coor = new_coor_left;\n      this.pivot = new_piv_left;\n    } else if (this.coor_is_valid(new_coor_right)) {\n      new_coor = new_coor_right;\n      this.pivot = new_piv_right;\n    } else if (this.coor_is_valid(new_coor_up)) {\n      new_coor = new_coor_up;\n      this.pivot = new_piv_up;\n    } else {\n      //Sets old coor as new coor, so no change is made\n      new_coor = coor;\n    }\n\n    //GO THROUGH AND REPLACE each coor WITH new_coor TO MAKE ROTATED PIECE\n    for (let i = 0; i < 4; i++) {\n      this.board[new_coor[i][0]][new_coor[i][1]] = typ;\n    }\n\n    this.update_ghost();\n    return new_coor;\n  }\n\n\n\n  shift_coor(Coordinates, piv, ver, hor){//SHIFTS COOR IN A GIVEN DIR\n    let shifted_coor = []\n    for (let i = 0; i < 4; i++) {\n      let temp = [];\n      temp[0] = Coordinates[i][0] + ver;\n      temp[1] = Coordinates[i][1] + hor;\n      shifted_coor[i] = temp;\n    }\n    let shifted_piv = [piv[0] + ver, piv[1] + hor];\n    return [shifted_coor, shifted_piv];\n  }\n\n  shift_piece(Coordinates, ver, hor){//SHIFTS COOR IN A GIVEN DIR\n    let typ = this.board[Coordinates[0][0]][Coordinates[0][1]];\n      for (let i = 0; i < 4; i++) {\n        this.board[Coordinates[i][0]][Coordinates[i][1]] = 0;\n      }\n      for (let i = 0; i < 4; i++) {\n        this.board[Coordinates[i][0] + ver][Coordinates[i][1] + hor] = typ;\n      }\n      this.pivot[0] += ver;\n      this.pivot[1] += hor;\n      this.update_ghost();\n  }\n\n\n  coor_is_valid(coors) {//CHECKS IF COOR IS VALID\n    let flag = true;\n    for (let i = 0; i < 4; i++) {\n      let row = coors[i][0];\n      let col = coors[i][1];\n      if (\n        row > this.board.length - 1 ||\n        row < 0 ||\n        col > this.board[0].length - 1 ||\n        col < 0\n      ) {\n        flag = false;\n        break;\n      }\n      let coor = this.board[row][col];\n      if (coor > 1) {\n        flag = false;\n      }\n    }\n    return flag;\n  }\n\n\n  \n  move_left() {\n    //CHECKS IF MOVE LEFT IS POSSIBLE, THEN DOES IT, OTHERWISE NOTHING\n    let coor = this.update_coor(); //grabs Coordinates\n    let new_coor = this.shift_coor(coor, this.pivot, 0, -1)[0];\n    if(this.coor_is_valid(new_coor)){\n      this.shift_piece(coor, 0, -1)\n    }\n    return true\n  }\n\n\n\n  move_right() {\n    //CHECKS IF MOVE RIGHT IS POSSIBLE, THEN DOES IT, OTHERWISE NOTHING\n    let coor = this.update_coor(); //grabs Coordinates\n    let new_coor = this.shift_coor(coor, this.pivot, 0, 1)[0];\n    if(this.coor_is_valid(new_coor)){\n      this.shift_piece(coor, 0, 1)\n    }\n    return true\n  }\n\n\n\n  move_drop() {\n    //SCANS FOR PEICE, WHEN FOUND IT DOES PIECE_FALL() UNTIL PIECE NO LONGER EXISTS\n    let check = this.piece_fall();\n    this.score_increase(100);\n    clearInterval(this.interval);\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n    return check;\n  }\n\n\n  hard_drop(){\n    let diff = 0;\n    let coor = this.update_coor();\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] === 1) {\n\n          //Used to add 2 points times level times the number of levels dropped\n          diff = 2*(row-coor[0][0]-1); \n\n          this.board[row][col] = this.board[coor[0][0]][coor[0][1]];\n        }\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] = 1;\n    }\n    this.score_increase(diff*100);\n    this.solidify_piece();\n    this.over_stack_check();\n    return true\n  }\n\n\n\n  move_hold_swap() {\n    if(this.hold_swapped === false) {\n      //SWAPS INTO HOLD\n      let coor = this.update_coor();\n      if (this.hold < 2) {\n        this.hold = -this.board[coor[0][0]][coor[0][1]];\n        for (let i = 0; i < 4; i++) {\n          this.board[coor[i][0]][coor[i][1]] = 0;\n        }\n        this.next_piece_grab();\n      } else {\n        let temp = 1 * -this.board[coor[0][0]][coor[0][1]];\n        for (let i = 0; i < 4; i++) {\n          this.board[coor[i][0]][coor[i][1]] = 0;\n        }\n        this.gen_piece(true, this.hold);\n        this.hold = 1 * temp; //copies without same memory\n      }\n      this.hold_swapped = true;\n      return this.hold;\n    }\n  }\n\n\n\n  next_piece_grab() {\n    if (this.next[0] === 0 || this.next[1] === 0) {\n      for (let i = 0; i < 3; i++) {\n        this.next[i] = this.gen_piece(false, 0);\n      }\n    }\n    let next_piece = 1 * this.next[0];\n    this.next = [this.next[1], this.next[2], this.gen_piece(false, 0)];\n    this.gen_piece(true, next_piece);\n    return next_piece;\n  }\n\n\n\n\n  solidify_piece() {\n    let coor = this.update_coor();\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] *= -1;\n    }\n    this.hold_swapped = false;\n    this.line_cleared_check();\n    this.next_piece_grab();\n  }\n\n  update_ghost() {\n    //removes old ghost tiles\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] === 1) {\n          this.board[row][col] = 0;\n        }\n      }\n    }\n\n    //PUTS THE GHOST piece in\n    let coor = this.update_coor();\n    let counter = 0;\n    let ghost_dist = 0;\n    let flag = true;\n    while (flag) {\n      counter++;\n      for (let i = 0; i < 4; i++) {\n        if (coor[i][0] + counter > this.board.length - 1) {\n          flag = false;\n        } else {\n          let spot = this.board[coor[i][0] + counter][coor[i][1]];\n          if (spot > 1) {\n            flag = false;\n          }\n        }\n      }\n      if (flag) {\n        ghost_dist++;\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      let spot = this.board[coor[i][0] + ghost_dist][coor[i][1]];\n      if (spot === 0) {\n        this.board[coor[i][0] + ghost_dist][coor[i][1]] = 1;\n      }\n    }\n    return ghost_dist;\n  }\n\n  line_cleared_check() {\n    let rows_clear = [];\n    for (let i = 0; i < this.board.length; i++) {\n      let row_cleared = true;\n      for (let j = 0; j < this.board[i].length; j++) {\n        if (this.board[i][j] <= 1) {\n          row_cleared = false;\n        }\n      }\n      if (row_cleared) {\n        rows_clear.push(i);\n      }\n    }\n    let cleared_lines_len = rows_clear.length;\n    this.score_increase(cleared_lines_len);\n\n    for (let i = 0; i < cleared_lines_len; i++) {\n      for (let j = 0; j < this.board[rows_clear[i]].length; j++) {\n        this.board[rows_clear[i]][j] = 0;\n      }\n    }\n    let row_cleared_max = Math.max(...rows_clear);\n\n    for (let i = row_cleared_max; i >= 0; i--) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        if (this.board[i][j] > 1) {\n          let counter = 0;\n          for (let each = 0; each < cleared_lines_len; each++) {\n            if (rows_clear[each] > i) {\n              counter++;\n            }\n          }\n          let temp = this.board[i][j];\n          this.board[i][j] = 0;\n          this.board[i + counter][j] = temp;\n        }\n      }\n    }\n\n    return rows_clear;\n  }\n\n  over_stack_check() {\n    //checks if stack goes above top, then ends if it does\n    let flag = true;\n    for(let i=0; i<this.board[3].length; i++){\n        if(this.board[3][i] > 0){\n          flag = false;\n        }\n    }\n    if(flag !== true){\n      let level_score = this.reset_all();\n      this.highscore = Math.max(level_score[1], this.highscore);\n      this.highlevel = Math.max(level_score[0], this.highlevel);\n    }\n  } \n\n  time_drop_calc(){\n    this.droptime = 700*((0.86)**(0.5*(this.level)))+200;\n  }\n\n  level_update(){\n    this.level = Math.max(this.level, Math.floor(     (-65+Math.sqrt(13*(325+this.score*2)))/130  ));\n    this.time_drop_calc();\n  }\n\n  reset_all(){\n    //RESETS THE BOARD AND ALL THE SCORE, RETURNS THE SCORE AND LEVEL\n    let score = this.score;\n    let level = this.level;\n    this.board = [];\n    this.score = 0;\n    this.level = 0;\n    this.droptime = 900;\n    this.pieces = [2,3,4,5,6,7,8] //tracks for tetris \"random generator\"\n    this.pivot = [];\n    this.coor = [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ];\n    this.hold = 0;\n    this.hold_swapped = false;\n    this.next = [0, 0, 0]; //stores next three not including one in play\n    this.create_board();\n    return [level, score];\n  }\n\n  score_increase(lines_cleared) {\n    //input of greater than 100 means I want to increment, not lines clear\n\n    if (lines_cleared > 4) {\n      let increment = lines_cleared/100;\n      this.score = this.score + increment*(this.level+1);\n    } else {\n      if (lines_cleared === 1) {\n        this.score = this.score + (this.level + 1) * 40;\n      }\n      if (lines_cleared === 2) {\n        this.score = this.score + (this.level + 1) * 100;\n      }\n      if (lines_cleared === 3) {\n        this.score = this.score + (this.level + 1) * 300;\n      }\n      if (lines_cleared === 4) {\n        this.score = this.score + (this.level + 1) * 1200;\n      }\n      this.level_update();\n    }\n    return this.score;\n  }\n\n  stop_drop(){\n    clearInterval(this.interval);\n  }\n\n  start_drop(){\n    clearInterval(this.interval);\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n  }\n}\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\n\nimport App from \"./App.js\"\n\nReactDOM.render(<App /> , document.getElementById('root'));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}