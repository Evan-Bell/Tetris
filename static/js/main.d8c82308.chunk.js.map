{"version":3,"sources":["reportWebVitals.js","BoardDisplay.js","Controls.js","useKeyPress.js","App.js","game.js","index.js"],"names":["reportWebVitals","onPerfEntry","Function","__webpack_require__","e","then","bind","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","StylizedBoardDisplay","props","game_board","inputboard","width","inputwidth","height","inputheight","rows_ind","row","push","cols_ind","col","c","react_default","a","createElement","className","map","id","board","ControlsDisplay","score","level","hold","next","highscore","highlevel","droptime","useKeyPress","callback","_useState","useState","_useState2","Object","slicedToArray","keyPressed","setKeyPressed","useEffect","downHandler","key","length","upHandler","window","addEventListener","removeEventListener","gameBoard","Board","_this","this","classCallCheck","pivot","pieces","coor","hold_swapped","interval","setInterval","piece_fall","create_board","temp","next_piece_grab","mutate","specific_piece","sort","Math","random","piece_num","pop","piece","2","3","4","5","6","7","8","g","update_ghost","ms","Promise","resolve","setTimeout","update_coor","flag","i","solidify_piece","over_stack_check","typ","counter","xPivot","yPivot","new_coor","slice","_this$shift_coor","shift_coor","new_coor_down","new_piv_down","_this$shift_coor2","new_coor_up","new_piv_up","_this$shift_coor3","new_coor_left","new_piv_left","_this$shift_coor4","new_coor_right","new_piv_right","coor_is_valid","Coordinates","piv","ver","hor","shifted_coor","coors","shift_piece","_this2","check","score_increase","clearInterval","diff","gen_piece","next_piece","line_cleared_check","ghost_dist","rows_clear","row_cleared","j","cleared_lines_len","max","apply","each","level_score","reset_all","pow","floor","sqrt","time_drop_calc","lines_cleared","increment","level_update","_this3","App","_useState$gameBoard$b","update_board","timerID","move_left","move_right","move_drop","rotate_piece","move_hold_swap","stop_drop","start_drop","hard_drop","ReactDOM","render","src_App","document","getElementById"],"mappings":"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","file":"static/js/main.d8c82308.chunk.js","sourcesContent":["const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\n\n\nexport default function StylizedBoardDisplay(props) {\n\n    var game_board = props.inputboard;\n    var width = props.inputwidth;\n    var height = props.inputheight;\n    \n    //DISPLAYS THE BOARD IN A WAY THAT I CAN VISUALLY CONFIRM CHANGES\n    let rows_ind = [];\n    for (let row = 0; row < height; row++) {\n      rows_ind.push(row);\n    }\n\n    let cols_ind = [];\n    for (let col = 0; col < width+2; col++) {\n      cols_ind.push(col);\n    }\n\n\n    let c = 'c'; //USED TO MAKE ID FOR EACH CELL 'C' FOLLOWED BY NUMBER\n    let r = 'r';\n    return (\n        <div className=\"TetrisBoard\">\n            <tr className='TetrisRow'> \n            {cols_ind.map((col) => <td className='TetrisCell' id={c+'Border'}></td> )} \n            </tr>\n        \n            {rows_ind.map((row) => (\n                <tr className='TetrisRow' id={r+row}> \n                    <td className='TetrisCell' id={c+'Border'}></td>\n                    {game_board.board[row].map((col) => <td className='TetrisCell' id={c+col}></td> )} \n                    <td className='TetrisCell' id={c+'Border'}></td>\n                </tr>\n            ))}\n\n            <tr className='TetrisRow'> \n            {cols_ind.map((col) => <td className='TetrisCell' id={c+'Border'}></td> )} \n            </tr>\n        </div>\n    );\n}","import React from 'react';\n\nexport default function ControlsDisplay(props) {\n    var game_board = props.inputboard\n    return (\n        <div className=\"TetrisControls\">\n            <div className='score-display'>Score: {game_board.score}</div>\n            <div className='level-display'>Level: {game_board.level}</div>\n            <div className='hold-display'>Hold: {game_board.hold}</div>\n            <div className='next-display'>Next: {game_board.next}</div>\n            <div className='highscore-display'>Highscore: {game_board.highscore}</div>\n            <div className='highlevel-display'>Highlevel: {game_board.highlevel}</div>\n            <div className='droptime'>droptime: {game_board.droptime}</div>\n        </div>\n    );\n}\n\n","import { useState, useEffect } from 'react';\n\n//1\nconst useKeyPress = callback => {\n  //2\n  const [keyPressed, setKeyPressed] = useState();\n  //3\n  useEffect(() => {\n    //4\n    const downHandler = ({ key }) => {\n      if (keyPressed !== key && key.length === 1) {\n        setKeyPressed(key);\n        callback && callback(key);\n      }\n    };\n    //5\n    const upHandler = () => {\n      setKeyPressed(null);\n    };\n\n    //6\n    window.addEventListener('keydown', downHandler);\n    window.addEventListener('keyup', upHandler);\n\n    return () => {\n      //7\n      window.removeEventListener('keydown', downHandler);\n      window.removeEventListener('keyup', upHandler);\n    };\n  });\n  //8\n  return keyPressed;\n};\n\nexport default useKeyPress;","import React from 'react'\nimport { useState, useEffect } from 'react';\nimport StylizedBoardDisplay from \"./BoardDisplay\"\nimport ControlsDisplay from './Controls';\nimport Board from \"./game\"\nimport useKeyPress from './useKeyPress';\n\n\n\n\nconst width = 10;\nconst height = 24; //playable height is 20\n\n\nvar gameBoard = new Board(width, height);\n\n\nfunction App() {\n\n    const [game_board, update_board] = useState[gameBoard.board]\n\n    useEffect(() => {\n        this.timerID = setInterval(\n            () => update_board(gameBoard.board),\n            100\n          );\n      }, gameBoard.board)\n\n    useKeyPress(key => {\n        switch(key) {\n            case 'ArrowLeft': \n                gameBoard.move_left();\n              break;\n            case 'ArrowRight': \n                gameBoard.move_right();\n                break;\n            case 'ArrowDown': \n                gameBoard.move_drop();\n                break;\n            case 'ArrowUp': \n                gameBoard.rotate_piece();\n                break;\n            case 'h':\n                gameBoard.move_hold_swap();\n                break;\n            case '-':\n                gameBoard.stop_drop();\n                break;\n            case '=':\n                gameBoard.start_drop();\n                break;\n            case ' ':\n                gameBoard.hard_drop();\n                break;\n        };\n    });\n\n    return(\n            <div className=\"TetrisGame\">\n                <ControlsDisplay inputboard={game_board}/>\n                <StylizedBoardDisplay inputboard={game_board} inputheight={height} inputwidth={width}/>\n            </div>\n    )\n}\n\nexport default App;","/*\nRULES FOR TETRIS\n\nSIZE OF BOARD = 10 WIDE, 20 TALL (24 TALL, BUT TOP 4 ARE NOT IN PLAY)\nTYPES OF PIECES = { ALL ARE SIZE 4 SQUARES :\n  T, \n  SQUARE, \n  LEFT L,\n  RIGHT L,\n  LEFT Z,\n  RIGHT Z,\n  STRAIGHT\n}\n\nACTIONS AVAIBLE = {\n  MOVE LEFT,\n  MOVE RIGHT, \n  DOWN,\n  ROTATE,\n  MOVE TO HOLD\n}\n\n\n\"NEXT\" contains 3 pieces to come next, not including one in play\n\"HOLD\" contains 1 piece which swaps with the piece in play\n\n\nSCORING = { BASED ON LEVEL (N) MULTIPLIED BY  NUMBER OF LINES CLEARED AT ONCE\n  ONE LINE = 40(N+1)\n  TWO LINES = 100(N+1)\n  THREE LINES 300(N+1)\n  FOUR LINES 1200(N+1)\n}\n*/\nexport default class Board {\n  //USED TO INITIALIZE THE BOARD\n\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n    this.board = [];\n    this.score = 0;\n    this.level = 0;\n    this.pivot = [];\n    this.pieces = [2,3,4,5,6,7,8] //tracks for tetris \"random generator\"\n    this.coor = [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ];\n    this.hold = 0;\n    this.hold_swapped = false\n    this.next = [0, 0, 0]; //stores next three not including one in play\n    this.highlevel = 0;\n    this.highscore = 0;\n    this.droptime = 900;\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n    this.create_board();\n  }\n\n  create_board() {\n    //CREATES BLANK 2D ARRAY OF GIVEN SIZE (HEIGHT AND WIDTH)\n    let temp = [];\n    for (let row = 0; row < this.height; row++) {\n      temp[row] = [];\n      for (let col = 0; col < this.width; col++) {\n        temp[row][col] = 0; //0;\n      }\n    }\n    this.board = temp;\n    this.next_piece_grab();\n\n    return this.board;\n  }\n\n  /*\n  TYPES OF PIECES AND CODE VALUES ASSIGNED TO THEM = {\n    EMPTY = 0\n    GHOST/VISUALIZED = 1\n    T = 2\n    SQUARE = 3\n    STRAIGHT LINE = 4\n    NORMAL L = 5\n    BACKWARDS L = 6\n    LEFT Z = 7\n    RIGHT Z = 8\n    (ALL ABOVE ARE FOR PEICE THAT ARE PLACED)\n    (FOR PIECES THAT ARE NOT PLACES, THE CODE WILL BE NEGATIVE THE NUMBER, SO UNPLACED T IS -1)\n  }\n  */\n\n\n\n  gen_piece(mutate, specific_piece) {\n    //GENERATES A NEW PIECE\n    const piece_codes = {\n      //EACH PIECE HAS A NUMBER AS A KEY (COLOR AND PEICE INDETIFIER) AND A SET OF 4 COORDINATEES, AND A PIVOT POINT\n      2: [\n        [0, 0],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], // RELATIVE PIVOT POINT\n      ],\n      3: [\n        [0, 0],\n        [0, 1],\n        [1, 0],\n        [1, 1],\n        [0.5, 0.5], //RELATIVE PIVOT POINT\n      ],\n      4: [\n        [0, -1],\n        [0, 0],\n        [0, 1],\n        [0, 2],\n        [0.5, 0.5], //RELATIVE PIVOT POINT\n      ],\n      5: [\n        [0, 1],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      6: [\n        [0, -1],\n        [1, -1],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      7: [\n        [0, -1],\n        [0, 0],\n        [1, 0],\n        [1, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n      8: [\n        [1, -1],\n        [0, 0],\n        [1, 0],\n        [0, 1],\n        [1, 0], //RELATIVE PIVOT POINT\n      ],\n    };  \n\n    if(this.pieces.length === 0){ //MAKES IT SO THAT EACH PIECE GETS GIVEN EVENLY\n      this.pieces = [2,3,4,5,6,7,8];\n    }\n    this.pieces = this.pieces.sort(() => {\n      return Math.random() - 0.5;\n    })\n    let piece_num = this.pieces.pop(this.pieces.length-1); //GETS LAST INT FROM RANDOM SORT LIST\n    if (specific_piece > 1) {\n      piece_num = 1 * specific_piece;\n    }\n    if (mutate) {\n      let piece = piece_codes[piece_num];\n      for (let g = 0; g < 4; g++) { //SHIFTS THE PIECE OVER TO CENTER OF BOARD INSTEAD OF DEAD TOP\n        this.board[piece[g][0] + 1][piece[g][1] + 4] = -piece_num;\n      }\n\n      this.pivot = piece[4];\n      this.pivot[0] += 1;\n      this.pivot[1] += 4; //MOVE THE PIVOT ACCORDINGLY WITH THE PIECE SHIFT ABOVE\n      this.update_ghost();\n    }\n    return piece_num;\n  }\n\n  sleep(ms) {//USED FOR FALLING TIMEOUT\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  piece_fall() {\n    //DROPS PIECE DOWN ONE\n    let coor = this.update_coor(); //grabs Coordinates\n    let flag = true;\n    for (let i = 0; i < 4; i++) {\n      let row = coor[i][0];\n      let col = coor[i][1];\n      if (row === this.height - 1 || this.board[row + 1][col] > 1) {\n        flag = false;\n      }\n    }\n    if (flag !== true) {\n      this.solidify_piece();\n      this.over_stack_check();\n    } else {\n      //REMOVES THE SPOT AT EACH OF COORDINATES AND ADDS ONE BELOW EACH COORDINATE\n\n      let typ = this.board[coor[0][0]][coor[0][1]];\n      for (let i = 0; i < 4; i++) {\n        this.board[coor[i][0]][coor[i][1]] = 0;\n      }\n      for (let i = 0; i < 4; i++) {\n        this.board[coor[i][0] + 1][coor[i][1]] = typ;\n      }\n      this.pivot[0] += 1;\n    }\n    return flag;\n  }\n\n  update_coor() {\n    let temp = [[], [], [], []];\n    let counter = 0;\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] < 0) {\n          this.coor[counter][0] = row;\n          this.coor[counter][1] = col;\n          temp[counter][0] = row;\n          temp[counter][1] = col;\n          counter++;\n        }\n      }\n    }\n    return temp;\n  }\n\n  rotate_piece() {\n    //ROTATES THE PIECE CLOCKWISE\n    // Rules for rotation taken from here https://gamedev.stackexchange.com/questions/17974/how-to-rotate-blocks-in-tetris\n\n    let coor = this.update_coor(); //grabs Coordinates\n\n    //COVERT EACH POINT RELATIVE TO PIVOT then rotates and stores in new_coor\n    let xPivot = this.pivot[0];\n    let yPivot = this.pivot[1];\n    let new_coor = coor.slice(); //copies but without same memory pointer\n    for (let g = 0; g < 4; g++) {\n      let temp = [0, 0];\n      temp[0] = xPivot + (coor[g][1] - yPivot);\n      temp[1] = yPivot + -(coor[g][0] - xPivot);\n      new_coor[g] = temp;\n    }\n\n    let typ = this.board[coor[0][0]][coor[0][1]]; //Stores value to use for replacing same piece\n    //REMOVES THE OLD COOR (NEW COOR IS STILL STORED, SO IT IS OK)\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] = 0;\n    }\n\n    //GENERATES COORDINATES AND PIV SHIFTED IN EVERY DIR\n    let {new_coor_down, new_piv_down} = this.shift_coor(new_coor, this.pivot, 1, 0);\n    let {new_coor_up, new_piv_up}= this.shift_coor(new_coor, this.pivot, -1, 0);\n    let {new_coor_left, new_piv_left} = this.shift_coor(new_coor, this.pivot, 0, -1);\n    let {new_coor_right, new_piv_right} = this.shift_coor(new_coor, this.pivot, 0, 1);\n\n    //CHECKS THAT NEW POSSIBLE COOR ARE VALID\n    if (this.coor_is_valid(new_coor)) {\n      let throw_away;\n    } else if (this.coor_is_valid(new_coor_down)) {\n      new_coor = new_coor_down;\n      this.pivot = new_piv_down;\n    } else if (this.coor_is_valid(new_coor_left)) {\n      new_coor = new_coor_left;\n      this.pivot = new_piv_left;\n    } else if (this.coor_is_valid(new_coor_right)) {\n      new_coor = new_coor_right;\n      this.pivot = new_piv_right;\n    } else if (this.coor_is_valid(new_coor_up)) {\n      new_coor = new_coor_up;\n      this.pivot = new_piv_up;\n    } else {\n      //Sets old coor as new coor, so no change is made\n      new_coor = coor;\n    }\n\n    //GO THROUGH AND REPLACE each coor WITH new_coor TO MAKE ROTATED PIECE\n    for (let i = 0; i < 4; i++) {\n      this.board[new_coor[i][0]][new_coor[i][1]] = typ;\n    }\n\n    this.update_ghost();\n    return new_coor;\n  }\n\n\n\n  shift_coor(Coordinates, piv, ver, hor){//SHIFTS COOR IN A GIVEN DIR\n    let shifted_coor = []\n    for (let i = 0; i < 4; i++) {\n      let temp = [];\n      temp[0] = Coordinates[i][0] + ver;\n      temp[1] = Coordinates[i][1] + hor;\n      shifted_coor[i] = temp;\n    }\n    let shifted_piv = [piv[0] + ver, piv[1] + hor];\n    return [shifted_coor, shifted_piv];\n  }\n\n  shift_piece(Coordinates, ver, hor){//SHIFTS COOR IN A GIVEN DIR\n    let typ = this.board[Coordinates[0][0]][Coordinates[0][1]];\n      for (let i = 0; i < 4; i++) {\n        this.board[Coordinates[i][0]][Coordinates[i][1]] = 0;\n      }\n      for (let i = 0; i < 4; i++) {\n        this.board[Coordinates[i][0] + ver][Coordinates[i][1] + hor] = typ;\n      }\n      this.pivot[0] += ver;\n      this.pivot[1] += hor;\n      this.update_ghost();\n  }\n\n\n  coor_is_valid(coors) {//CHECKS IF COOR IS VALID\n    let flag = true;\n    for (let i = 0; i < 4; i++) {\n      let row = coors[i][0];\n      let col = coors[i][1];\n      if (\n        row > this.board.length - 1 ||\n        row < 0 ||\n        col > this.board[0].length - 1 ||\n        col < 0\n      ) {\n        flag = false;\n        break;\n      }\n      let coor = this.board[row][col];\n      if (coor > 1) {\n        flag = false;\n      }\n    }\n    return flag;\n  }\n\n\n  \n  move_left() {\n    //CHECKS IF MOVE LEFT IS POSSIBLE, THEN DOES IT, OTHERWISE NOTHING\n    let coor = this.update_coor(); //grabs Coordinates\n    let new_coor = this.shift_coor(coor, this.pivot, 0, -1)[0];\n    if(this.coor_is_valid(new_coor)){\n      this.shift_piece(coor, 0, -1)\n    }\n    return true\n  }\n\n\n\n  move_right() {\n    //CHECKS IF MOVE RIGHT IS POSSIBLE, THEN DOES IT, OTHERWISE NOTHING\n    let coor = this.update_coor(); //grabs Coordinates\n    let new_coor = this.shift_coor(coor, this.pivot, 0, 1)[0];\n    if(this.coor_is_valid(new_coor)){\n      this.shift_piece(coor, 0, 1)\n    }\n    return true\n  }\n\n\n\n  move_drop() {\n    //SCANS FOR PEICE, WHEN FOUND IT DOES PIECE_FALL() UNTIL PIECE NO LONGER EXISTS\n    let check = this.piece_fall();\n    this.score_increase(100);\n    clearInterval(this.interval);\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n    return check;\n  }\n\n\n  hard_drop(){\n    let diff = 0;\n    let coor = this.update_coor();\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] === 1) {\n\n          //Used to add 2 points times level times the number of levels dropped\n          diff = 2*(row-coor[0][0]-1); \n\n          this.board[row][col] = this.board[coor[0][0]][coor[0][1]];\n        }\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] = 1;\n    }\n    this.score_increase(diff*100);\n    this.solidify_piece();\n    this.over_stack_check();\n    return true\n  }\n\n\n\n  move_hold_swap() {\n    if(this.hold_swapped === false) {\n      //SWAPS INTO HOLD\n      let coor = this.update_coor();\n      if (this.hold < 2) {\n        this.hold = -this.board[coor[0][0]][coor[0][1]];\n        for (let i = 0; i < 4; i++) {\n          this.board[coor[i][0]][coor[i][1]] = 0;\n        }\n        this.next_piece_grab();\n      } else {\n        let temp = 1 * -this.board[coor[0][0]][coor[0][1]];\n        for (let i = 0; i < 4; i++) {\n          this.board[coor[i][0]][coor[i][1]] = 0;\n        }\n        this.gen_piece(true, this.hold);\n        this.hold = 1 * temp; //copies without same memory\n      }\n      this.hold_swapped = true;\n      return this.hold;\n    }\n  }\n\n\n\n  next_piece_grab() {\n    if (this.next[0] === 0 || this.next[1] === 0) {\n      for (let i = 0; i < 3; i++) {\n        this.next[i] = this.gen_piece(false, 0);\n      }\n    }\n    let next_piece = 1 * this.next[0];\n    this.next = [this.next[1], this.next[2], this.gen_piece(false, 0)];\n    this.gen_piece(true, next_piece);\n    return next_piece;\n  }\n\n\n\n\n  solidify_piece() {\n    let coor = this.update_coor();\n    for (let i = 0; i < 4; i++) {\n      this.board[coor[i][0]][coor[i][1]] *= -1;\n    }\n    this.hold_swapped = false;\n    this.line_cleared_check();\n    this.next_piece_grab();\n  }\n\n  update_ghost() {\n    //removes old ghost tiles\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        if (this.board[row][col] === 1) {\n          this.board[row][col] = 0;\n        }\n      }\n    }\n\n    //PUTS THE GHOST piece in\n    let coor = this.update_coor();\n    let counter = 0;\n    let ghost_dist = 0;\n    let flag = true;\n    while (flag) {\n      counter++;\n      for (let i = 0; i < 4; i++) {\n        if (coor[i][0] + counter > this.board.length - 1) {\n          flag = false;\n        } else {\n          let spot = this.board[coor[i][0] + counter][coor[i][1]];\n          if (spot > 1) {\n            flag = false;\n          }\n        }\n      }\n      if (flag) {\n        ghost_dist++;\n      }\n    }\n    for (let i = 0; i < 4; i++) {\n      let spot = this.board[coor[i][0] + ghost_dist][coor[i][1]];\n      if (spot === 0) {\n        this.board[coor[i][0] + ghost_dist][coor[i][1]] = 1;\n      }\n    }\n    return ghost_dist;\n  }\n\n  line_cleared_check() {\n    let rows_clear = [];\n    for (let i = 0; i < this.board.length; i++) {\n      let row_cleared = true;\n      for (let j = 0; j < this.board[i].length; j++) {\n        if (this.board[i][j] <= 1) {\n          row_cleared = false;\n        }\n      }\n      if (row_cleared) {\n        rows_clear.push(i);\n      }\n    }\n    let cleared_lines_len = rows_clear.length;\n    this.score_increase(cleared_lines_len);\n\n    for (let i = 0; i < cleared_lines_len; i++) {\n      for (let j = 0; j < this.board[rows_clear[i]].length; j++) {\n        this.board[rows_clear[i]][j] = 0;\n      }\n    }\n    let row_cleared_max = Math.max(...rows_clear);\n\n    for (let i = row_cleared_max; i >= 0; i--) {\n      for (let j = 0; j < this.board[i].length; j++) {\n        if (this.board[i][j] > 1) {\n          let counter = 0;\n          for (let each = 0; each < cleared_lines_len; each++) {\n            if (rows_clear[each] > i) {\n              counter++;\n            }\n          }\n          let temp = this.board[i][j];\n          this.board[i][j] = 0;\n          this.board[i + counter][j] = temp;\n        }\n      }\n    }\n\n    return rows_clear;\n  }\n\n  over_stack_check() {\n    //checks if stack goes above top, then ends if it does\n    let flag = true;\n    for(let i=0; i<this.board[3].length; i++){\n        if(this.board[3][i] > 0){\n          flag = false;\n        }\n    }\n    if(flag !== true){\n      let level_score = this.reset_all();\n      this.highscore = Math.max(level_score[1], this.highscore);\n      this.highlevel = Math.max(level_score[0], this.highlevel);\n    }\n  } \n\n  time_drop_calc(){\n    this.droptime = 700*((0.86)**(0.5*(this.level)))+200;\n  }\n\n  level_update(){\n    this.level = Math.max(this.level, Math.floor(     (-65+Math.sqrt(13*(325+this.score*2)))/130  ));\n    this.time_drop_calc();\n  }\n\n  reset_all(){\n    //RESETS THE BOARD AND ALL THE SCORE, RETURNS THE SCORE AND LEVEL\n    let score = this.score;\n    let level = this.level;\n    this.board = [];\n    this.score = 0;\n    this.level = 0;\n    this.droptime = 900;\n    this.pieces = [2,3,4,5,6,7,8] //tracks for tetris \"random generator\"\n    this.pivot = [];\n    this.coor = [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ];\n    this.hold = 0;\n    this.hold_swapped = false;\n    this.next = [0, 0, 0]; //stores next three not including one in play\n    this.create_board();\n    return [level, score];\n  }\n\n  score_increase(lines_cleared) {\n    //input of greater than 100 means I want to increment, not lines clear\n\n    if (lines_cleared > 4) {\n      let increment = lines_cleared/100;\n      this.score = this.score + increment*(this.level+1);\n    } else {\n      if (lines_cleared === 1) {\n        this.score = this.score + (this.level + 1) * 40;\n      }\n      if (lines_cleared === 2) {\n        this.score = this.score + (this.level + 1) * 100;\n      }\n      if (lines_cleared === 3) {\n        this.score = this.score + (this.level + 1) * 300;\n      }\n      if (lines_cleared === 4) {\n        this.score = this.score + (this.level + 1) * 1200;\n      }\n      this.level_update();\n    }\n    return this.score;\n  }\n\n  stop_drop(){\n    clearInterval(this.interval);\n  }\n\n  start_drop(){\n    clearInterval(this.interval);\n    this.interval = setInterval(() => {this.piece_fall()}, this.droptime);\n  }\n}\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\n\nimport App from \"./App.js\"\n\nReactDOM.render(<App /> , document.getElementById('root'));\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}